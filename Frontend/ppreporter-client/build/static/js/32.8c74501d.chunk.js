"use strict";(self.webpackChunkppreporter_client=self.webpackChunkppreporter_client||[]).push([[32],{20032:(e,t,r)=>{r.r(t),r.d(t,{default:()=>j});var n=r(65043),i=r(79183),o=r(71985),a=r(50007),s=r(31951),l=r(58168),c=r(84391),d=r(19435);const u=new d.Pq0,m=new d.Pq0,h=new d.Pq0,f=new d.I9Y;function p(e,t,r){const n=u.setFromMatrixPosition(e.matrixWorld);n.project(t);const i=r.width/2,o=r.height/2;return[n.x*i+i,-n.y*o+o]}const x=e=>Math.abs(e)<1e-10?0:e;function v(e,t){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"",n="matrix3d(";for(let i=0;16!==i;i++)n+=x(t[i]*e.elements[i])+(15!==i?",":")");return r+n}const y=(g=[1,-1,1,1,1,-1,1,1,1,-1,1,1,1,-1,1,1],e=>v(e,g));var g;const b=(e,t)=>{return v(e,[1/(r=t),1/r,1/r,1,-1/r,-1/r,-1/r,-1,1/r,1/r,1/r,1,1,1,1,1],"translate(-50%,-50%)");var r};const M=n.forwardRef(((e,t)=>{let{children:r,eps:o=.001,style:a,className:s,prepend:v,center:g,fullscreen:M,portal:P,distanceFactor:w,sprite:j=!1,transform:E=!1,occlude:z,onOcclude:S,castShadow:$,receiveShadow:R,material:W,geometry:k,zIndexRange:F=[16777271,0],calculatePosition:A=p,as:C="div",wrapperClass:I,pointerEvents:L="auto",...T}=e;const{gl:H,camera:O,scene:Y,size:G,raycaster:N,events:q,viewport:B}=(0,i.D)(),[D]=n.useState((()=>document.createElement(C))),X=n.useRef(),Z=n.useRef(null),_=n.useRef(0),U=n.useRef([0,0]),V=n.useRef(null),J=n.useRef(null),K=(null==P?void 0:P.current)||q.connected||H.domElement.parentNode,Q=n.useRef(null),ee=n.useRef(!1),te=n.useMemo((()=>z&&"blending"!==z||Array.isArray(z)&&z.length&&function(e){return e&&"object"===typeof e&&"current"in e}(z[0])),[z]);n.useLayoutEffect((()=>{const e=H.domElement;z&&"blending"===z?(e.style.zIndex=`${Math.floor(F[0]/2)}`,e.style.position="absolute",e.style.pointerEvents="none"):(e.style.zIndex=null,e.style.position=null,e.style.pointerEvents=null)}),[z]),n.useLayoutEffect((()=>{if(Z.current){const e=X.current=c.createRoot(D);if(Y.updateMatrixWorld(),E)D.style.cssText="position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";else{const e=A(Z.current,O,G);D.style.cssText=`position:absolute;top:0;left:0;transform:translate3d(${e[0]}px,${e[1]}px,0);transform-origin:0 0;`}return K&&(v?K.prepend(D):K.appendChild(D)),()=>{K&&K.removeChild(D),e.unmount()}}}),[K,E]),n.useLayoutEffect((()=>{I&&(D.className=I)}),[I]);const re=n.useMemo((()=>E?{position:"absolute",top:0,left:0,width:G.width,height:G.height,transformStyle:"preserve-3d",pointerEvents:"none"}:{position:"absolute",transform:g?"translate3d(-50%,-50%,0)":"none",...M&&{top:-G.height/2,left:-G.width/2,width:G.width,height:G.height},...a}),[a,g,M,G,E]),ne=n.useMemo((()=>({position:"absolute",pointerEvents:L})),[L]);n.useLayoutEffect((()=>{var e,i;(ee.current=!1,E)?null==(e=X.current)||e.render(n.createElement("div",{ref:V,style:re},n.createElement("div",{ref:J,style:ne},n.createElement("div",{ref:t,className:s,style:a,children:r})))):null==(i=X.current)||i.render(n.createElement("div",{ref:t,style:re,className:s,children:r}))}));const ie=n.useRef(!0);(0,i.F)((e=>{if(Z.current){O.updateMatrixWorld(),Z.current.updateWorldMatrix(!0,!1);const e=E?U.current:A(Z.current,O,G);if(E||Math.abs(_.current-O.zoom)>o||Math.abs(U.current[0]-e[0])>o||Math.abs(U.current[1]-e[1])>o){const t=function(e,t){const r=u.setFromMatrixPosition(e.matrixWorld),n=m.setFromMatrixPosition(t.matrixWorld),i=r.sub(n),o=t.getWorldDirection(h);return i.angleTo(o)>Math.PI/2}(Z.current,O);let r=!1;te&&(Array.isArray(z)?r=z.map((e=>e.current)):"blending"!==z&&(r=[Y]));const n=ie.current;if(r){const e=function(e,t,r,n){const i=u.setFromMatrixPosition(e.matrixWorld),o=i.clone();o.project(t),f.set(o.x,o.y),r.setFromCamera(f,t);const a=r.intersectObjects(n,!0);if(a.length){const e=a[0].distance;return i.distanceTo(r.ray.origin)<e}return!0}(Z.current,O,N,r);ie.current=e&&!t}else ie.current=!t;n!==ie.current&&(S?S(!ie.current):D.style.display=ie.current?"block":"none");const i=Math.floor(F[0]/2),o=z?te?[F[0],i]:[i-1,0]:F;if(D.style.zIndex=`${function(e,t,r){if(t instanceof d.ubm||t instanceof d.qUd){const n=u.setFromMatrixPosition(e.matrixWorld),i=m.setFromMatrixPosition(t.matrixWorld),o=n.distanceTo(i),a=(r[1]-r[0])/(t.far-t.near),s=r[1]-a*t.far;return Math.round(a*o+s)}}(Z.current,O,o)}`,E){const[e,t]=[G.width/2,G.height/2],r=O.projectionMatrix.elements[5]*t,{isOrthographicCamera:n,top:i,left:o,bottom:a,right:s}=O,l=y(O.matrixWorldInverse),c=n?`scale(${r})translate(${x(-(s+o)/2)}px,${x((i+a)/2)}px)`:`translateZ(${r}px)`;let d=Z.current.matrixWorld;j&&(d=O.matrixWorldInverse.clone().transpose().copyPosition(d).scale(Z.current.scale),d.elements[3]=d.elements[7]=d.elements[11]=0,d.elements[15]=1),D.style.width=G.width+"px",D.style.height=G.height+"px",D.style.perspective=n?"":`${r}px`,V.current&&J.current&&(V.current.style.transform=`${c}${l}translate(${e}px,${t}px)`,J.current.style.transform=b(d,1/((w||10)/400)))}else{const t=void 0===w?1:function(e,t){if(t instanceof d.qUd)return t.zoom;if(t instanceof d.ubm){const r=u.setFromMatrixPosition(e.matrixWorld),n=m.setFromMatrixPosition(t.matrixWorld),i=t.fov*Math.PI/180,o=r.distanceTo(n);return 1/(2*Math.tan(i/2)*o)}return 1}(Z.current,O)*w;D.style.transform=`translate3d(${e[0]}px,${e[1]}px,0) scale(${t})`}U.current=e,_.current=O.zoom}}if(!te&&Q.current&&!ee.current)if(E){if(V.current){const e=V.current.children[0];if(null!=e&&e.clientWidth&&null!=e&&e.clientHeight){const{isOrthographicCamera:t}=O;if(t||k)T.scale&&(Array.isArray(T.scale)?T.scale instanceof d.Pq0?Q.current.scale.copy(T.scale.clone().divideScalar(1)):Q.current.scale.set(1/T.scale[0],1/T.scale[1],1/T.scale[2]):Q.current.scale.setScalar(1/T.scale));else{const t=(w||10)/400,r=e.clientWidth*t,n=e.clientHeight*t;Q.current.scale.set(r,n,1)}ee.current=!0}}}else{const t=D.children[0];if(null!=t&&t.clientWidth&&null!=t&&t.clientHeight){const e=1/B.factor,r=t.clientWidth*e,n=t.clientHeight*e;Q.current.scale.set(r,n,1),ee.current=!0}Q.current.lookAt(e.camera.position)}}));const oe=n.useMemo((()=>({vertexShader:E?void 0:'\n          /*\n            This shader is from the THREE\'s SpriteMaterial.\n            We need to turn the backing plane into a Sprite\n            (make it always face the camera) if "transfrom"\n            is false.\n          */\n          #include <common>\n\n          void main() {\n            vec2 center = vec2(0., 1.);\n            float rotation = 0.0;\n\n            // This is somewhat arbitrary, but it seems to work well\n            // Need to figure out how to derive this dynamically if it even matters\n            float size = 0.03;\n\n            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n            vec2 scale;\n            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\n            bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n            if ( isPerspective ) scale *= - mvPosition.z;\n\n            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;\n            vec2 rotatedPosition;\n            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n            mvPosition.xy += rotatedPosition;\n\n            gl_Position = projectionMatrix * mvPosition;\n          }\n      ',fragmentShader:"\n        void main() {\n          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n        }\n      "})),[E]);return n.createElement("group",(0,l.A)({},T,{ref:Z}),z&&!te&&n.createElement("mesh",{castShadow:$,receiveShadow:R,ref:Q},k||n.createElement("planeGeometry",null),W||n.createElement("shaderMaterial",{side:d.$EB,vertexShader:oe.vertexShader,fragmentShader:oe.fragmentShader})))}));var P=r(70579);const w=e=>{var t,r;let{normalizedData:o,autoRotate:l,rotationSpeed:c,enableZoom:d,enableRotation:u,enableGrid:m,enableAxes:h,enableLabels:f,darkMode:p,xLabel:x,yLabel:v,zLabel:y,chartType:g,getPointColor:b,getPointSize:w,handlePointClick:j,selectedPoint:E,hoveredPoint:z,setHoveredPoint:S}=e;const{camera:$}=(0,i.D)(),R=(0,n.useRef)(),W="dark"===(null===(t=(0,i.D)().gl.domElement.parentElement)||void 0===t||null===(r=t.parentElement)||void 0===r?void 0:r.getAttribute("data-theme"))?{palette:{primary:{main:"#90caf9"},success:{main:"#66bb6a"},error:{main:"#f44336"}}}:{palette:{primary:{main:"#1976d2"},success:{main:"#2e7d32"},error:{main:"#d32f2f"}}};return(0,n.useEffect)((()=>{$.position.set(10,10,10),$.lookAt(0,0,0)}),[$]),(0,i.F)((()=>{l&&R.current&&(R.current.autoRotateSpeed=c,R.current.update())})),(0,P.jsxs)(P.Fragment,{children:[(0,P.jsx)(a.N,{ref:R,autoRotate:l,enableZoom:d,enableRotate:u,enablePan:!0}),(0,P.jsx)("ambientLight",{intensity:p?.3:.5}),(0,P.jsx)("directionalLight",{position:[10,10,10],intensity:p?.7:1,castShadow:!0}),m&&(0,P.jsx)("gridHelper",{args:[10,10,p?4473924:13421772,p?2236962:14737632],position:[0,-5,0]}),h&&(0,P.jsxs)(P.Fragment,{children:[(0,P.jsxs)("line",{children:[(0,P.jsx)("bufferGeometry",{attach:"geometry",children:(0,P.jsx)("bufferAttribute",{attach:"attributes-position",args:[new Float32Array([-5,-5,-5,5,-5,-5]),3,!1]})}),(0,P.jsx)("lineBasicMaterial",{attach:"material",color:W.palette.error.main,linewidth:2})]}),(0,P.jsxs)("line",{children:[(0,P.jsx)("bufferGeometry",{attach:"geometry",children:(0,P.jsx)("bufferAttribute",{attach:"attributes-position",args:[new Float32Array([-5,-5,-5,-5,5,-5]),3,!1]})}),(0,P.jsx)("lineBasicMaterial",{attach:"material",color:W.palette.success.main,linewidth:2})]}),(0,P.jsxs)("line",{children:[(0,P.jsx)("bufferGeometry",{attach:"geometry",children:(0,P.jsx)("bufferAttribute",{attach:"attributes-position",args:[new Float32Array([-5,-5,-5,-5,-5,5]),3,!1]})}),(0,P.jsx)("lineBasicMaterial",{attach:"material",color:W.palette.primary.main,linewidth:2})]}),(0,P.jsx)(s.E,{position:[6,-5,-5],color:W.palette.error.main,fontSize:.5,anchorX:"center",anchorY:"middle",children:x}),(0,P.jsx)(s.E,{position:[-5,6,-5],color:W.palette.success.main,fontSize:.5,anchorX:"center",anchorY:"middle",children:v}),(0,P.jsx)(s.E,{position:[-5,-5,6],color:W.palette.primary.main,fontSize:.5,anchorX:"center",anchorY:"middle",children:y})]}),"3dScatter"===g&&o.map((e=>(0,P.jsxs)("mesh",{position:[e.normalizedX,e.normalizedY,e.normalizedZ],scale:w(e),onClick:()=>j(e),onPointerOver:()=>S(e),onPointerOut:()=>S(null),children:[(0,P.jsx)("sphereGeometry",{args:[1,32,32]}),(0,P.jsx)("meshStandardMaterial",{color:b(e),roughness:.5,metalness:.2,emissive:(null===E||void 0===E?void 0:E.id)===e.id?"#ffffff":"#000000",emissiveIntensity:(null===E||void 0===E?void 0:E.id)===e.id?.5:0}),f&&(e.label||(null===z||void 0===z?void 0:z.id)===e.id)&&(0,P.jsx)(M,{position:[0,1.2,0],center:!0,style:{backgroundColor:"rgba(0, 0, 0, 0.7)",color:"white",padding:"4px 8px",borderRadius:"4px",fontSize:"12px",pointerEvents:"none",whiteSpace:"nowrap"},children:e.label||`(${e.x}, ${e.y}, ${e.z})`})]},e.id))),"3dBar"===g&&o.map((e=>(0,P.jsxs)("mesh",{position:[e.normalizedX,(e.normalizedY+5)/2,e.normalizedZ],scale:[w(e),Math.max(.1,e.normalizedY+5),w(e)],onClick:()=>j(e),onPointerOver:()=>S(e),onPointerOut:()=>S(null),children:[(0,P.jsx)("boxGeometry",{args:[1,1,1]}),(0,P.jsx)("meshStandardMaterial",{color:b(e),roughness:.5,metalness:.2,emissive:(null===E||void 0===E?void 0:E.id)===e.id?"#ffffff":"#000000",emissiveIntensity:(null===E||void 0===E?void 0:E.id)===e.id?.5:0}),f&&(e.label||(null===z||void 0===z?void 0:z.id)===e.id)&&(0,P.jsx)(M,{position:[0,(e.normalizedY+5)/2+.6,0],center:!0,style:{backgroundColor:"rgba(0, 0, 0, 0.7)",color:"white",padding:"4px 8px",borderRadius:"4px",fontSize:"12px",pointerEvents:"none",whiteSpace:"nowrap"},children:e.label||`(${e.x}, ${e.y}, ${e.z})`})]},e.id)))]})},j=e=>(0,P.jsx)(o.Hl,{camera:{position:[10,10,10],fov:60},style:{background:e.darkMode?"#111":"#f5f5f5"},children:(0,P.jsx)(w,{...e})})}}]);
//# sourceMappingURL=32.8c74501d.chunk.js.map