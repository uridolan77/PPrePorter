{"version":3,"file":"static/js/8554.ae631b21.chunk.js","mappings":"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","sources":["components/reports/visualizations/ThreeSurfaceComponents.tsx"],"sourcesContent":["import React, { useRef, useEffect, useCallback, useMemo } from 'react';\nimport { Canvas, useFrame, useThree } from '@react-three/fiber';\nimport { OrbitControls, Text } from '@react-three/drei';\nimport * as THREE from 'three';\nimport { SurfaceDataPoint } from './Surface3DPlot';\nimport { SurfaceInterpolationMethod } from '../../../components/utils/interpolationUtils';\nimport { Theme } from '@mui/material';\n\ninterface SceneProps {\n  data: SurfaceDataPoint[];\n  autoRotate: boolean;\n  rotationSpeed: number;\n  enableZoom: boolean;\n  enableRotation: boolean;\n  enableGrid: boolean;\n  enableAxes: boolean;\n  darkMode: boolean;\n  xLabel: string;\n  yLabel: string;\n  zLabel: string;\n  surfaceResolution: number;\n  selectedInterpolation: SurfaceInterpolationMethod;\n  showWireframe: boolean;\n  selectedColorMap: string;\n  xRange?: [number, number];\n  yRange?: [number, number];\n  onPointClick?: (point: SurfaceDataPoint) => void;\n  theme: Theme;\n}\n\n// Scene component\nconst Scene: React.FC<SceneProps> = ({\n  data,\n  autoRotate,\n  rotationSpeed,\n  enableZoom,\n  enableRotation,\n  enableGrid,\n  enableAxes,\n  darkMode,\n  xLabel,\n  yLabel,\n  zLabel,\n  surfaceResolution,\n  selectedInterpolation,\n  showWireframe,\n  selectedColorMap,\n  xRange,\n  yRange,\n  onPointClick,\n  theme\n}) => {\n  const { camera } = useThree();\n  const controlsRef = useRef<any>();\n  const meshRef = useRef<THREE.Mesh>(null);\n\n  // Set initial camera position\n  useEffect(() => {\n    camera.position.set(10, 10, 10);\n    camera.lookAt(0, 0, 0);\n  }, [camera]);\n\n  // Auto-rotate\n  useFrame(() => {\n    if (autoRotate && controlsRef.current) {\n      controlsRef.current.autoRotateSpeed = rotationSpeed;\n      controlsRef.current.update();\n    }\n  });\n\n  // Process data and create surface\n  const { positions, colors, indices } = useMemo(() => {\n    // Determine x and y ranges\n    const xMin = xRange ? xRange[0] : Math.min(...data.map(p => p.x));\n    const xMax = xRange ? xRange[1] : Math.max(...data.map(p => p.x));\n    const yMin = yRange ? yRange[0] : Math.min(...data.map(p => p.y));\n    const yMax = yRange ? yRange[1] : Math.max(...data.map(p => p.y));\n    const zMin = Math.min(...data.map(p => p.z));\n    const zMax = Math.max(...data.map(p => p.z));\n\n    // Mock interpolation function for now\n    // In a real implementation, this would call the actual interpolation function\n    const mockInterpolateSurface = (\n      data: SurfaceDataPoint[],\n      resolution: number,\n      method: string,\n      xRange: [number, number],\n      yRange: [number, number]\n    ) => {\n      // Create a simple grid for demonstration\n      const vertices: { x: number; y: number; z: number }[] = [];\n      const indices: number[] = [];\n      \n      const xStep = (xRange[1] - xRange[0]) / resolution;\n      const yStep = (yRange[1] - yRange[0]) / resolution;\n      \n      // Generate vertices\n      for (let i = 0; i <= resolution; i++) {\n        for (let j = 0; j <= resolution; j++) {\n          const x = xRange[0] + i * xStep;\n          const y = yRange[0] + j * yStep;\n          \n          // Simple function for z (can be replaced with actual interpolation)\n          let z = 0;\n          let totalWeight = 0;\n          \n          // Simple inverse distance weighting\n          data.forEach(point => {\n            const dx = point.x - x;\n            const dy = point.y - y;\n            const distance = Math.sqrt(dx * dx + dy * dy);\n            \n            if (distance < 0.001) {\n              z = point.z;\n              totalWeight = 1;\n            } else {\n              const weight = 1 / (distance * distance);\n              z += point.z * weight;\n              totalWeight += weight;\n            }\n          });\n          \n          if (totalWeight > 0) {\n            z /= totalWeight;\n          }\n          \n          vertices.push({ x, y, z });\n        }\n      }\n      \n      // Generate indices for triangles\n      for (let i = 0; i < resolution; i++) {\n        for (let j = 0; j < resolution; j++) {\n          const a = i * (resolution + 1) + j;\n          const b = i * (resolution + 1) + j + 1;\n          const c = (i + 1) * (resolution + 1) + j;\n          const d = (i + 1) * (resolution + 1) + j + 1;\n          \n          // First triangle\n          indices.push(a, b, c);\n          \n          // Second triangle\n          indices.push(b, d, c);\n        }\n      }\n      \n      return { vertices, indices };\n    };\n\n    // Interpolate surface\n    const surface = mockInterpolateSurface(\n      data,\n      surfaceResolution,\n      selectedInterpolation,\n      [xMin, xMax],\n      [yMin, yMax]\n    );\n\n    // Create positions array\n    const positions = new Float32Array(surface.vertices.length * 3);\n    for (let i = 0; i < surface.vertices.length; i++) {\n      const vertex = surface.vertices[i];\n      positions[i * 3] = vertex.x;\n      positions[i * 3 + 1] = vertex.z; // Use z as y in Three.js\n      positions[i * 3 + 2] = vertex.y; // Use y as z in Three.js\n    }\n\n    // Create colors array based on z values\n    const colors = new Float32Array(surface.vertices.length * 3);\n    for (let i = 0; i < surface.vertices.length; i++) {\n      const z = surface.vertices[i].z;\n      const normalizedZ = (z - zMin) / (zMax - zMin || 1);\n\n      // Apply color map\n      let r = 0, g = 0, b = 0;\n\n      switch (selectedColorMap) {\n        case 'heatmap':\n          // Blue to red heatmap\n          r = normalizedZ;\n          g = 0;\n          b = 1 - normalizedZ;\n          break;\n\n        case 'terrain':\n          // Terrain colors (blue-green-yellow-brown)\n          if (normalizedZ < 0.2) {\n            // Deep blue to light blue\n            r = 0;\n            g = normalizedZ * 2;\n            b = 0.5 + normalizedZ * 2.5;\n          } else if (normalizedZ < 0.4) {\n            // Light blue to green\n            r = 0;\n            g = 0.4 + (normalizedZ - 0.2) * 3;\n            b = 1 - (normalizedZ - 0.2) * 5;\n          } else if (normalizedZ < 0.7) {\n            // Green to yellow\n            r = (normalizedZ - 0.4) * 3.33;\n            g = 1;\n            b = 0;\n          } else {\n            // Yellow to brown\n            r = 1;\n            g = 1 - (normalizedZ - 0.7) * 3.33;\n            b = 0;\n          }\n          break;\n\n        case 'plasma':\n          // Plasma-like colors\n          r = 0.5 + 0.5 * Math.sin(normalizedZ * Math.PI * 2);\n          g = 0.5 + 0.5 * Math.sin(normalizedZ * Math.PI * 2 + Math.PI / 2);\n          b = 0.5 + 0.5 * Math.sin(normalizedZ * Math.PI * 2 + Math.PI);\n          break;\n\n        case 'rainbow':\n        default:\n          // Rainbow colors\n          const hue = (1 - normalizedZ) * 240; // Blue to red\n          const s = 1;\n          const l = 0.5;\n\n          // HSL to RGB conversion\n          const c = (1 - Math.abs(2 * l - 1)) * s;\n          const x = c * (1 - Math.abs((hue / 60) % 2 - 1));\n          const m = l - c / 2;\n\n          if (hue < 60) {\n            r = c; g = x; b = 0;\n          } else if (hue < 120) {\n            r = x; g = c; b = 0;\n          } else if (hue < 180) {\n            r = 0; g = c; b = x;\n          } else if (hue < 240) {\n            r = 0; g = x; b = c;\n          } else if (hue < 300) {\n            r = x; g = 0; b = c;\n          } else {\n            r = c; g = 0; b = x;\n          }\n\n          r = r + m;\n          g = g + m;\n          b = b + m;\n      }\n\n      colors[i * 3] = r;\n      colors[i * 3 + 1] = g;\n      colors[i * 3 + 2] = b;\n    }\n\n    return { positions, colors, indices: surface.indices };\n  }, [data, surfaceResolution, selectedInterpolation, selectedColorMap, xRange, yRange]);\n\n  // Handle point click\n  const handleClick = useCallback((event: THREE.Event) => {\n    if (!onPointClick) return;\n\n    // Get intersection point\n    const intersection = (event as any).intersections?.[0];\n    if (!intersection) return;\n\n    // Convert to data space\n    const point = intersection.point;\n\n    // Find closest data point\n    let closestPoint = data[0];\n    let minDistance = Infinity;\n\n    data.forEach(dataPoint => {\n      const distance = Math.sqrt(\n        Math.pow(dataPoint.x - point.x, 2) +\n        Math.pow(dataPoint.y - point.z, 2) + // y and z are swapped in Three.js\n        Math.pow(dataPoint.z - point.y, 2)\n      );\n\n      if (distance < minDistance) {\n        minDistance = distance;\n        closestPoint = dataPoint;\n      }\n    });\n\n    onPointClick(closestPoint);\n  }, [data, onPointClick]);\n\n  return (\n    <>\n      <OrbitControls\n        ref={controlsRef}\n        autoRotate={autoRotate}\n        enableZoom={enableZoom}\n        enableRotate={enableRotation}\n        enablePan={true}\n      />\n\n      {/* Ambient light */}\n      <ambientLight intensity={darkMode ? 0.3 : 0.5} />\n\n      {/* Directional light */}\n      <directionalLight\n        position={[10, 10, 10]}\n        intensity={darkMode ? 0.7 : 1}\n        castShadow\n      />\n\n      {/* Grid */}\n      {enableGrid && (\n        <gridHelper\n          args={[10, 10, darkMode ? 0x444444 : 0xcccccc, darkMode ? 0x222222 : 0xe0e0e0]}\n          position={[0, -5, 0]}\n          rotation={[Math.PI / 2, 0, 0]}\n        />\n      )}\n\n      {/* Axes */}\n      {enableAxes && (\n        <>\n          {/* X axis */}\n          <line>\n            <bufferGeometry attach=\"geometry\">\n              <bufferAttribute\n                attach=\"attributes-position\"\n                args={[new Float32Array([-5, -5, -5, 5, -5, -5]), 3, false]}\n              />\n            </bufferGeometry>\n            <lineBasicMaterial\n              attach=\"material\"\n              color={theme.palette.error.main}\n              linewidth={2}\n            />\n          </line>\n\n          {/* Y axis */}\n          <line>\n            <bufferGeometry attach=\"geometry\">\n              <bufferAttribute\n                attach=\"attributes-position\"\n                args={[new Float32Array([-5, -5, -5, -5, 5, -5]), 3, false]}\n              />\n            </bufferGeometry>\n            <lineBasicMaterial\n              attach=\"material\"\n              color={theme.palette.success.main}\n              linewidth={2}\n            />\n          </line>\n\n          {/* Z axis */}\n          <line>\n            <bufferGeometry attach=\"geometry\">\n              <bufferAttribute\n                attach=\"attributes-position\"\n                args={[new Float32Array([-5, -5, -5, -5, -5, 5]), 3, false]}\n              />\n            </bufferGeometry>\n            <lineBasicMaterial\n              attach=\"material\"\n              color={theme.palette.primary.main}\n              linewidth={2}\n            />\n          </line>\n\n          {/* Axis labels */}\n          <Text\n            position={[6, -5, -5]}\n            color={theme.palette.error.main}\n            fontSize={0.5}\n            anchorX=\"center\"\n            anchorY=\"middle\"\n          >\n            {xLabel}\n          </Text>\n\n          <Text\n            position={[-5, 6, -5]}\n            color={theme.palette.success.main}\n            fontSize={0.5}\n            anchorX=\"center\"\n            anchorY=\"middle\"\n          >\n            {zLabel}\n          </Text>\n\n          <Text\n            position={[-5, -5, 6]}\n            color={theme.palette.primary.main}\n            fontSize={0.5}\n            anchorX=\"center\"\n            anchorY=\"middle\"\n          >\n            {yLabel}\n          </Text>\n        </>\n      )}\n\n      {/* Surface mesh */}\n      <mesh ref={meshRef} onClick={handleClick}>\n        <bufferGeometry>\n          <bufferAttribute\n            attach=\"attributes-position\"\n            args={[positions, 3, false]}\n          />\n          <bufferAttribute\n            attach=\"attributes-color\"\n            args={[colors, 3, false]}\n          />\n          <bufferAttribute\n            attach=\"index\"\n            args={[new Uint16Array(indices), 1, false]}\n          />\n        </bufferGeometry>\n        <meshStandardMaterial\n          vertexColors\n          wireframe={showWireframe}\n          side={THREE.DoubleSide}\n          roughness={0.5}\n          metalness={0.2}\n        />\n      </mesh>\n\n      {/* Original data points */}\n      {data.map((point, index) => (\n        <mesh\n          key={`point-${index}`}\n          position={[point.x, point.z, point.y]} // y and z are swapped in Three.js\n          scale={0.1}\n        >\n          <sphereGeometry args={[1, 16, 16]} />\n          <meshStandardMaterial color=\"#ffffff\" />\n        </mesh>\n      ))}\n    </>\n  );\n};\n\ninterface ThreeSurfaceComponentsProps {\n  data: SurfaceDataPoint[];\n  autoRotate: boolean;\n  rotationSpeed: number;\n  enableZoom: boolean;\n  enableRotation: boolean;\n  enableGrid: boolean;\n  enableAxes: boolean;\n  darkMode: boolean;\n  xLabel: string;\n  yLabel: string;\n  zLabel: string;\n  surfaceResolution: number;\n  selectedInterpolation: SurfaceInterpolationMethod;\n  showWireframe: boolean;\n  selectedColorMap: string;\n  xRange?: [number, number];\n  yRange?: [number, number];\n  onPointClick?: (point: SurfaceDataPoint) => void;\n  theme: Theme;\n}\n\nconst ThreeSurfaceComponents: React.FC<ThreeSurfaceComponentsProps> = (props) => {\n  return (\n    <Canvas\n      camera={{ position: [10, 10, 10], fov: 60 }}\n      style={{ background: props.darkMode ? '#111' : '#f5f5f5' }}\n    >\n      <Scene {...props} />\n    </Canvas>\n  );\n};\n\nexport default ThreeSurfaceComponents;\n"],"names":["Scene","_ref","data","autoRotate","rotationSpeed","enableZoom","enableRotation","enableGrid","enableAxes","darkMode","xLabel","yLabel","zLabel","surfaceResolution","selectedInterpolation","showWireframe","selectedColorMap","xRange","yRange","onPointClick","theme","camera","useThree","controlsRef","useRef","meshRef","useEffect","position","set","lookAt","useFrame","current","autoRotateSpeed","update","positions","colors","indices","useMemo","xMin","Math","min","map","p","x","xMax","max","yMin","y","yMax","zMin","z","zMax","surface","mockInterpolateSurface","resolution","method","vertices","xStep","yStep","i","j","totalWeight","forEach","point","dx","dy","distance","sqrt","weight","push","a","b","c","d","Float32Array","length","vertex","normalizedZ","r","g","sin","PI","hue","s","l","abs","m","handleClick","useCallback","event","_intersections","intersection","intersections","closestPoint","minDistance","Infinity","dataPoint","pow","_jsxs","_Fragment","children","_jsx","OrbitControls","ref","enableRotate","enablePan","intensity","castShadow","args","rotation","attach","color","palette","error","main","linewidth","success","primary","Text","fontSize","anchorX","anchorY","onClick","Uint16Array","vertexColors","wireframe","side","THREE","roughness","metalness","index","scale","props","Canvas","fov","style","background"],"sourceRoot":""}